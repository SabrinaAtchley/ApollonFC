#ifndef APOLLON_FC_CONFIGURATION_H
#define APOLLON_FC_CONFIGURATION_H

/* System Configuration
 *
 * Configures system wide settings which are agnostic of hardware
 */

#include "src/macros.h"

#define ERROR_MESSAGE_0
#define ERROR_MESSAGE_1 "Err1: IMU self test failed"
#define ERROR_MESSAGE_2 "Err2: Receiver channel number out of bounds"
#define ERROR_MESSAGE_3 "Err3: I2C device misconfiguration - check wires and addresses"
#define ERROR_MESSAGE_4
#define ERROR_MESSAGE_5
#define ERROR_MESSAGE_6
#define ERROR_MESSAGE_7
#define ERROR_MESSAGE_8
#define ERROR_MESSAGE_9
#define ERROR_MESSAGE_10
#define ERROR_MESSAGE_11
#define ERROR_MESSAGE_12
#define ERROR_MESSAGE_13
#define ERROR_MESSAGE_14
#define ERROR_MESSAGE_15 "Err15: Unspecified runtime error"



/* Input Configuration
 *
 * Configures pilot input parameters, e.g. deadzone width,
 * receiver type and setup, channels
 */

/* Minimum and Maximum signals that are generated by the radio controller,
 * and the limits that can be sent to the ESCs
 */
#define INPUT_MOTOR_MIN 1000
#define INPUT_MOTOR_MAX 2000
/* This value should be set somewhere in the middle of the INPUT_MOTOR min and max
 * It should be the lowest value the motors can spin at when armed, providing
 * negligible force.
 * Recommend 5% of range to start with (e.g. range [1000, 2000] = 1050)
 */
#define INPUT_IDLE_SIG  1050

// Input deadzones (snapping points)
#define INPUT_DEADZONE_WIDTH 30
#define INPUT_DEADZONE_STOPS (1000, 1500, 2000)


/* Pilot input limits
* Sets minimum and maximum rotational speeds, angles, and linear verticalspeed (height)
* YAWSPEED, ROLLSPEED, and PITCHSPEED are limits on the angular velocity for
*   yaw, roll and pitch axes, in degrees per second.
*   E.G. PILOT_YAWSPEED_MIN -15.0; PILOT_YAWSPEED_MAX 25.0 allows faster rotation
*   towards starboard and slower towards port
*
*   Yaw: negative turns nose to port, positive turns nose to starboard
*   Roll: negative turns starboard to port, positive turns port to starboard
*   Pitch: negative turns nose down, positive turns nose up
*   x:
*/

// °/s
#define PILOT_YAWSPEED_MIN    -200.0
#define PILOT_YAWSPEED_MAX     200.0
#define PILOT_ROLLSPEED_MIN   -300.0
#define PILOT_ROLLSPEED_MAX    300.0
#define PILOT_PITCHSPEED_MIN  -300.0
#define PILOT_PITCHSPEED_MAX   300.0
// °
// There is no yaw angle limit, why is left as an exercise to the reader.
#define PILOT_ROLLANGLE_MIN    -10.0
#define PILOT_ROLLANGLE_MAX     10.0
#define PILOT_PITCHANGLE_MIN   -10.0
#define PILOT_PITCHANGLE_MAX    10.0
// m/s
#define PILOT_VERTICALSPEED_MIN   -2.0
#define PILOT_VERTICALSPEED_MAX   10.0

// microseconds
#define PILOT_THROTTLE_MIN 1000
#define PILOT_THROTTLE_MID 1350 // Recommend to be tuned to the hoverpoint
#define PILOT_THROTTLE_MAX 2000
/* Midpoint values. These are the output values for when the sticks are in
 * the neutral position. You almost certainly want these to be kept at 0.
 */
#define PILOT_YAWSPEED_MID      0
#define PILOT_ROLLSPEED_MID     0
#define PILOT_PITCHSPEED_MID    0
#define PILOT_ROLLANGLE_MID     0
#define PILOT_PITCHANGLE_MID    0
#define PILOT_VERTICALSPEED_MID 0
/* Response curve variables
 * Response curves govern how the signal is interpolated from the min, mid, and max
 * point. with very negative c value creating a flat response near the midpoint,
 * giving a lot of fine control near the midpoint, and a very positive c value
 * giving a more uniform response throughout the range.
 *
 * Interactive response curve example
 * https://www.desmos.com/calculator/ppkshnsd6s
 *
 * k values can take on any float value, but since it is an exponent, there are
 * diminishing returns. Values between roughly [-3, 3] are recommended, but feel
 * free to go outside this if you really want.
 * Again,
 *  -value: flatter around midpoint, more control when moving slowly
 *  +value: steeper around midpoint, more uniform control across range
 */
#define PILOT_YAWSPEED_K       0.5
#define PILOT_ROLLSPEED_K      0.5
#define PILOT_PITCHSPEED_K     0.5
#define PILOT_ROLLANGLE_K     -3.0
#define PILOT_PITCHANGLE_K    -3.0
#define PILOT_VERTICALSPEED_K -0.5
#define PILOT_THROTTLE_K -0.5

/* Number of entries, expressed as an exponent of 2, to include in each lookup
 * table (LUT) for the response curve profiles. There are currently 6 LUTs, and
 * each entry is 32 bits (4 bytes).
 * Default: 6 (2^6 = 64 entries per LUT)
 *
 * If you notice your input is feeling step-y, try upping this number, but do be
 * aware of progmem constraints.
 *
 * Range: integer from [1, 15] (32kB is about 2^10 with 6 LUTs of floats)
 */
#define PILOT_RESPONSE_CURVE_LUT_SIZE 6 // Default: 6 (64 entries)


// Receiver configuration

// Receiver type
#define INPUT_RECEIVER_PPM
//#define INPUT_RECEIVER_PWM
//#define INPUT_RECEIVER_SBUS
//#define INPUT_RECEIVER_IBUS

#define INPUT_RECEIVER_IS_SERIAL

// PPM Receiver setup
//#define PPM_MAX_ERROR 10 // Default: 10; Small leeway to account for minor errors
//#define PPM_BLANK_TIME 2100 // Default: 2100; Needs to be greater than INPUT_MOTOR_MAX + PPM_MAX_ERROR


#if ENABLED(INPUT_RECEIVER_IS_SERIAL)
  #define SERIAL_RECEIVER_PIN 2
#else
  #define PARALLEL_RECEIVER_PINS {2, 3, 4, 5, 6, 7, 8, 9, 10, 11}
#endif



// Receiver Channel setup
// Total number of supported channels
#define INPUT_CHANNELS 10
// Sets up channel control aliases; Does *not* need one for each channel
#define INPUT_CHANNEL_ROLL 1
#define INPUT_CHANNEL_PITCH 2
#define INPUT_CHANNEL_THROTTLE 3
#define INPUT_CHANNEL_YAW 4
#define INPUT_CHANNEL_SWA 5
#define INPUT_CHANNEL_SWB 6
#define INPUT_CHANNEL_SWC 7
#define INPUT_CHANNEL_SWD 8
#define INPUT_SOFT_ARM_SWITCH INPUT_CHANNEL_SWA // Used for software arming/disarming
#define INPUT_FLIGHT_MODE_SWITCH INPUT_CHANNEL_SWB // Input to use for mode switching

/* Flight modes
 * Supported modes:
 *  FLIGHT_MODE_ACRO // Interprets inputs as desired angular rate, maintaining angle when neutral
 *  FLIGHT_MODE_ANGLE // Interprets inputs as desired angle, maintaining level attitude when neutral
 */

#define FLIGHT_MODE_DEFAULT FLIGHT_MODE_ANGLE
#define FLIGHT_MODE_SWITCH_MODE FLIGHT_MODE_ACRO // Mode to switch to when on (off switches to default)

/* Flight mode byte values. Configuration is unlikely to be
 * necessary unless you are adding a new mode
 */
#define FLIGHT_MODE_UNDEF 0x00 // Reserved for error states such as a misconfiguration of FLIGHT_MODE_DEFAULT
#define FLIGHT_MODE_ANGLE 0x01
#define FLIGHT_MODE_ACRO 0x02

/* Peripheral Configuration
 *
 * Configures small peripherals such as buzzers, buttons, LEDs
 */

// Buzzer
#define PERIPHERAL_BUZZER_PIN 8
// Used for error beeps
#define PERIPHERAL_BUZZER_HIGH 784
#define PERIPHERAL_BUZZER_LOW 392
#define PERIPHERAL_BUZZER_TONE_LENGTH 200
#define PERIPHERAL_BUZZER_INTERTONE_DELAY 200
#define PERIPHERAL_BUZZER_REPEAT_DELAY 2000
// Uses uint8_t, so max is 8 bits
#define PERIPHERAL_BUZZER_MAX_BITS 4
// quarter note length (ms)
#define PERIPHERAL_BUZZER_QUARTER 800
// Drone startup melody
// Metroid! A5 D6 C6 A5 G5
#define PERIPHERAL_BUZZER_STARTUP ((880, PERIPHERAL_BUZZER_QUARTER), (1175, PERIPHERAL_BUZZER_QUARTER), (1047, PERIPHERAL_BUZZER_QUARTER), (880, PERIPHERAL_BUZZER_QUARTER), (784, 1.5*PERIPHERAL_BUZZER_QUARTER))


/* ESC and Motor Configuration
 *
 * Configuration for Electronic Speed Controllers and motors
 */
#define MOTOR_AMOUNT 4
// motor 1, 2, 3, 4
#define ESC_PINS (6 , 9, 10, 11) //TODO: CHECK PINS AGAINST MOTOR NUMBERS
// #define ESC_DO_CALIBRATION // Uncomment to automatically calibrate ESCs on startup every time

/* Possibile configurations:
 * QUAD_X
 * QUAD_PLUS
 *
 */
#define DRONE_CONFIGURATION QUAD_X

/* Motor mixing matrices
 * row 1 - contribution of motor 1 to throttle, roll, pitch, yaw
 * row 2 - contribution of motor 2 to throttle, roll, pitch, yaw
 * row 3 - contribution of motor 3 to throttle, roll, pitch, yaw
 * row 4 - contribution of motor 4 to throttle, roll, pitch, yaw
 * and so on for higher rotor counts
 * In NED, roll right = +x, pitch down = +y, yaw right = +z
 */
#define MOTOR_MIXING_MATRIX_QUAD_X { { 1.0, -1.0, -1.0,  1.0}, \
                                     { 1.0,  1.0,  1.0,  1.0}, \
                                     { 1.0,  1.0, -1.0, -1.0}, \
                                     { 1.0, -1.0,  1.0, -1.0} }

#define MOTOR_MIXING_MATRIX_QUAD_PLUS { { 1.0, -1.0,  0.0, -1.0}, \
                                        { 1.0,  1.0,  0.0, -1.0}, \
                                        { 1.0,  0.0, -1.0,  1.0}, \
                                        { 1.0,  0.0,  1.0,  1.0} }


#define MOTOR_MIXING_MATRIX CAT(MOTOR_MIXING_MATRIX_, DRONE_CONFIGURATION)


/* Sensor modules
 *
 * Defines which sensors should be loaded and used
 * In-depth sensor configuration such as device address
 * can be found in sensor-configuration.h
 */

// #define SENSOR_BMP180
// #define SENSOR_HMC5883L
#define SENSOR_MPU6050

/* Invert Sensor axis
 *
 * Used to rotate axis
 * Note: You should invert *exactly two or zero* axis to keep the right hand rule
 */

#define SENSOR_INVERT_X
// #define SENSOR_INVERT_Y
#define SENSOR_INVERT_Z


/* PID Configuration
 *
 * PID controllers take the error between the target state and estimate state
 * as output by the sensor fusion algorithm and pilot control module
 */

 /* PID output range is mostly arbitrary. It can affect aggressiveness of response,
  * but this is probably better tuned with the coefficients and/or motor mixing matrix
  * Consider this the "maximum authority" for each axis
  */
 #define PID_OUTPUT_RANGE_MIN -200
 #define PID_OUTPUT_RANGE_MAX 200
 /* PID coefficients
  * These are the main PID tuning settings.
  * Each tuple contains the (kp, ki, kd) coefficients, for the
  * proportional, integral, and derivative terms, respectively.
  * In general:
  *   the proportional term determine how aggressive the response is to current error
  *   the integral term corrects for long-term and steady state errors over time
  *   the derivative term dampens the over and undershoots typical of the integral term
  * For more information, please consult a PID tuning guide online
  */
 #define PID_YAW_COEFFICIENTS      ARG_LIST(35, 20, 0)
 #define PID_PITCH_COEFFICIENTS    ARG_LIST(60, 45, 0)
 #define PID_ROLL_COEFFICIENTS     ARG_LIST(60, 45, 0)
 /* P values for angle controllers
  * Related to PIDs, angle mode uses a proportional controller for
  * converting pitch/roll angles -> rate setpoints. This affects how
  * "aggressively" we make that correction
  */
 #define P_PITCHSPEED 3.5
 #define P_ROLLSPEED 1.5
 /* PID scales
  * These scales are for more convenient coefficients. The "true" coefficient
  * used is just k * scale, e.g. kp * pScale
  * The use here is instead of using a kp of 120, you can have
  * kp = 1.2 and pScale = 100. If you want, you can set these to 1 and just use
  * the coefficients on their own.
  *
  * (pScale, iScale, dScale)
  */
 #define PID_YAW_SCALE      ARG_LIST(10, 1, 10)
 #define PID_PITCH_SCALE    ARG_LIST(10, 1, 10)
 #define PID_ROLL_SCALE     ARG_LIST(10, 1, 10)
 /* Lower and upper limits for integral terms
  * WARNING: large limits can and produce very large over and undershoots
  * and present a safety hazard to you and your equipment. Modify with caution
  */
 #define PID_YAW_INTEGRAL_LIMITS      ARG_LIST(-60, 60)
 #define PID_PITCH_INTEGRAL_LIMITS    ARG_LIST(-80, 80)
 #define PID_ROLL_INTEGRAL_LIMITS     ARG_LIST(-80, 80)

 /* Madgwick filter configuration
  * ACCEL_GATE_LOW: low value in g's to accept accelerometer data. Lower values
  *   may produce filter inaccuracies during maneuvers
  * ACCEL_GATE_HIGH: high value in g's to accept accelerometer data. Higher values
  *  may produce filter inaccuracies during maneuvers
  */

  #define ACCEL_GATE_LOW 0.75
  #define ACCEL_GATE_HIGH 1.25

  // Madgwick tuning parameter — typically ~ sqrt(3/4) * gyro noise (in rad/s)
  #define MADGWICK_BETA 0.2


#endif
